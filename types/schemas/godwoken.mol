import blockchain;

/* contract types */

array Byte20 [byte; 20];
array Byte65 [byte; 65];

/* Global state
 * We use single Byte32 to digest global state.
 * For the purpose of dynamic accumulate and easy to verify, 
 * Mountain merkle range(MMR) is chosen as our accumulator.
 * Reference implementation: https://github.com/nervosnetwork/merkle-mountain-range
 */
struct GlobalState {
    account_root: Byte32, // H(count | merkle root of address entries)
    block_root: Byte32, // merkle root of godwoken blocks
}

struct AccountEntry {
    index: Uint32, // address index
    pubkey_hash: Byte20, // pubkey hash -> blake2b160(secp256k1 pubkey)
    nonce: Uint32, // nonce
    balance: Uint64, // balance
    is_aggregator: byte, // a flag to indicates account is a aggregator
}

struct Tx {
    from_index: Uint32,
    to_index: Uint32,
    amount: Uint64, // amount of shannons
    fee: Uint64, // tx fee
    nonce: Uint32, // nonce
    signature: Byte65, // user signature
}

vector Txs <Tx>;

struct AggregatorBlock {
    number: Uint32, // block number
    tx_root: Byte32,
    old_account_root: Byte32,
    new_account_root: Byte32,
    pubkey: Byte20, // Aggregator's pubkey
    signature: Byte65, // Aggregator's signature
}

/* contract allowed actions */

union Action {
    Register,
    Deposit,
    SubmitBlock,
}

/* Register a new entry */
table Register {
    entry: AccountEntry,
    last_entry_hash: Byte32, // used for merkle proof
    mmr_size: Uint64, // MMR size
    proof: Byte32Vec, // merkle proof of old state address entry
}

/* Deposit coins */
table Deposit {
    old_entry: AccountEntry, // AccountEntry contains old state.
    new_entry: AccountEntry, // AccountEntry contains new state.
    count: Uint32, // count of entries, do not includes new_entry
    mmr_size: Uint64, // MMR size
    proof: Byte32Vec, // merkle proof of old state address entry
}

/* Submit aggregator block */
table SubmitBlock {
    txs: Txs,
    block: AggregatorBlock,
    last_block_hash: Byte32, // last blocks hash
    block_mmr_size: Uint64, // MMR size
    block_proof: Byte32Vec, // merkle proof of block_root
    aggregator_mmr_size: Uint64, // MMR size
    aggregator_proof: Byte32Vec, // merkle proof of aggregator_root
}
