import blockchain;

/* contract types */

array Byte65 [byte; 65];

/* Global state
 * We use single Byte32 to digest global state.
 * For the purpose of dynamic accumulate and easy to verify, 
 * Mountain merkle range(MMR) is chosen as our accumulator.
 * Reference implementation: https://github.com/nervosnetwork/merkle-mountain-range
 */
struct GlobalState {
    account_root: Byte32, // H(count | merkle root of address entries)
    block_root: Byte32, // merkle root of godwoken blocks
}

table AccountScript {
    code_hash: Byte32,
    args: Bytes,
}

table Account {
    index: Uint32, // address index
    script: AccountScript, // account's code
    nonce: Uint32, // nonce
    balance: Uint64, // balance
    is_ag: byte, // a flag to indicates account is a aggregator
}

vector AccountVec <Account>;

table Tx {
    account_index: Uint32,
    nonce: Uint32, // nonce
    args: Bytes, // args
    fee: Uint32, // fee
    witness: Bytes, // tx witness
}

vector TxVec <Tx>;

/* Aggregated block */
table AgBlock {
    number: Uint32, // block number
    tx_root: Byte32,
    state_checkpoints: Byte32Vec, // account root check points
    ag_sig: Byte65, // Aggregator's signature
    ag_index: Uint32, // Aggregator's index
}

/* contract allowed actions */

union Action {
    Register,
    Deposit,
    SubmitBlock,
    InvalidBlock,
}

/* Register a new account */
table Register {
    account: Account,
    last_account_hash: Byte32, // used for merkle proof
    proof: Byte32Vec, // merkle proof of old state
}

/* Deposit coins */
table Deposit {
    old_account: Account, // Account contains old state.
    new_account: Account, // Account contains new state.
    count: Uint32, // count of entries, do not includes new_account
    proof: Byte32Vec, // merkle proof of old state
}

/* Submit aggregator block */
table SubmitBlock {
    txs: TxVec,
    block: AgBlock,
    last_block_hash: Byte32, // last blocks hash
    block_proof: Byte32Vec, // merkle proof of block_root
    ag_account: Account, // aggregator's account
    account_proof: Byte32Vec, // merkle proof of aggregator_root
    account_count: Uint32,
}

/* Invalid a block */
table InvalidBlock {
    block: AgBlock, // invalid block
    block_proof: Byte32Vec, // merkle proof of block exists
    checkpoint_index: Uint32, // checkpoint which contains the initial state
    touched_accounts: AccountVec, // touch accounts previous state
    touched_accounts_proof: Byte32Vec, // proof of touched account state
    accounts_count: Uint32,
    txs: TxVec, // transactions during invalid checkpoint
    txs_proof: Byte32Vec, // merkle proof txs exists
    txs_count: Uint32,
    challenger_index: Uint32, // reward will send to this account
}

/* Godwoken contract */

union BasicAccountArgs {
    BATransfer,
}

struct BATransfer {
    to: Uint32,
    amount: Uint64,
}
